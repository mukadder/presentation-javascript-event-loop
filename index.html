<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>JavaScript Event Loop</title>
    <link rel="stylesheet" href="./reveal.js-3.2.0/css/reveal.css" />
    <link rel="stylesheet" href="./reveal.js-3.2.0/css/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./zenburn.css"/ >
    <style>
      .reveal pre {
        box-shadow: none;
        margin: 0;
        width: auto;
      }
      .reveal pre code {
        font-size: 90%;
        line-height: 1.2em;
        max-height: none;
      }
      .reveal .hljs {
        background-color: transparent;
      }
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
        text-transform: none;
        color: #affa42;
      }
      .reveal section img {
        border: 0px;
        background-color: transparent;
        margin: 0px;
        box-shadow: none;
      }
      .reveal .floater {
        position: absolute;
        top: 0px;
      }
      .reveal .floater code {
        font-size: 0.5em;
        display: block;
      }
      .reveal .floater-left {
        left: 0px;
      }
      .reveal .floater-right {
        right: 0px;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>The JavaScript Event Loop</h2>
          <p>Presented by Thomas Hunter II</p>
          <p><small><a href="https://twitter.com/tlhunter">@tlhunter</a></small></p>
          <!--<p><small>(Originally presented at Penguicon 2013)</small></p>-->
        </section>

        <section>
          <h3>What does Multi-Threaded mean?</h3>
          <ul>
            <li>Makes use of separate CPU Cores via “Threads”
              <ul>
                <li>Does so using a single process</li>
              </ul>
            </li>
            <li>True concurrency, lets you do two things at once</li>
            <li>Race Conditions, deadlocks, simultaneous memory usage</li>
            <li>“Hard” to get it right, problems are hard to debug</li>
            <li>Moore's Law, ran out of Ghz, add more cores</li>
          </ul>
        </section>

        <section>
          <h3>JavaScript is Single-Threaded</h3>
          <ul>
            <li>Makes use of a single CPU thread</li>
            <li>CPU intensive work is never “concurrent”</li>
            <li>Easier to pull off and reason about</li>
            <li>Unfortunate side-effects such as Scroll Jank</li>
          </ul>
        </section>

        <section>
          <section>
            <h3>Technical Implementation</h3>
            <ul>
              <li>
                Stack:
                <ul>
                  <li>Function calls, context information</li>
                  <li>As functions call functions, add frames to stack</li>
                </ul>
              </li>
              <li>
                Queue:
                <ul>
                  <li>Gets added to stack when previous stack empties</li>
                  <li>E.g. setTimeout() and setInterval() add to queue</li>
                </ul>
              </li>
              <li>
                Heap:
                <ul>
                  <li>“Chaotic” collection of objects, context vars, etc.</li>
                  <li>Garbage Collection cleans items from heap</li>
                </ul>
              </li>
              <li>
                Event Handlers:
                <ul>
                  <li>Can add items to queue in the future</li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h3>Beautiful Diagram</h3>

            <img style="max-width: 300px; max-height: 300px;" src="images/stack-heap-queue.svg" />

            <p><small>Credit: Mozilla Developer Network:<br /><a href="http://mzl.la/Y5Dh2x">http://mzl.la/Y5Dh2x</a></small></p>
          </section>

        </section>

        <section class="side-by-side">
          <section>
            <h3>Example Code-run</h3>
            <pre>
              <code class="javascript">
                function run() {
                  console.log("Adding code to the queue");

                  setTimeout(function c() { // c() Added somewhere in Heap
                    console.log("Running next code from queue");
                  }, 0);

                  function a(x) { // a() Added somewhere in Heap
                    console.log("a() frame added to stack");
                    b(x);
                    console.log("a() frame removed from stack");
                  }

                  function b(y) { // b() Added somewhere in Heap
                    console.log("b() frame added to stack");
                    console.log("Value passed in is " + y);
                    console.log("b() frame removed from stack");
                  }

                  a(42);

                  console.log("Ending work for this stack");
                }
              </code>
            </pre>
          </section>

          <section>
            <h3>Code-run Output, Flame Graph</h3>

            <img src="./images/flamegraph.png" />

            <ul>
              <li>Adding code to the queue </li>
              <li>a() frame added to stack</li>
              <li>b() frame added to stack</li>
              <li>Value passed in is 42</li>
              <li>b() frame removed from stack</li>
              <li>a() frame removed from stack</li>
              <li>Ending work for this stack</li>
              <li>Running next code from queue</li>
            </ul>
          </section>
        </section>

        <section>
          <h3>Your App is Mostly Asleep</h3>
          <ul>
            <li>Node.js: 
              <ul>
                <li>All I/O is non-blocking (libuv)</li>
                <li>C++ API does the heavy lifting</li>
                <li>Once I/O is complete callback is queued up</li>
              </ul>
            </li>
            <li>Browser
              <ul>
                <li>Wait for a click to happen</li>
              </ul>
            </li>
            <li>PHP
              <ul>
                <li>Wait for a MySQL query to run</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Sequential vs Parallel</h3>
          <ul>
            <li>Traditional web apps perform each I/O Sequentially</li>
            <li>With an Event Loop, they can be run in Parallel</li>
            <li>Since most time is spent waiting for I/O, very inefficient</li>
          </ul>

          <h5>Sequential I/O</h5>
          <img width="480" height="92" src="./images/sequential.svg" />

          <h5>Parallel I/O</h5>
          <img width="480" height="92" src="./images/parallel.svg" />
        </section>

        <section>
          <h3>Event Loops are Awesome!</h3>
          <ul>
            <li>No concurrent memory access problems</li>
            <li>Usually web apps spend most time waiting on I/O</li>
            <li>Easily perform I/O operations “in parallel”
              <ul>
                <li>Thanks to non-blocking APIs</li>
              </ul>
            </li>
            <li>Long running apps, don’t need separate web servers</li>
          </ul>
        </section>

        <section>
          <h3>Event Loops aren’t Awesome!</h3>

          <ul>
            <li>CPU intensive work will block your process
              <ul>
                <li>Though you can send work to other Node processes</li>
              </ul>
            </li>
            <li>It isn’t making use of those 8 cores you bought
              <ul>
                <li>Though you can use the Multi-Node module</li>
              </ul>
            </li>
            <li>Memory leaks are possible, not so with PHP
              <ul>
                <li>Though you can write your apps more carefully ;-)</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <div class="floater floater-left">
            <button id="work-current">Current Thread</button> 
            <code id="work-current-result">...</code>
          </div>

          <script>
            var buttonCurrent = document.getElementById('work-current');
            var resultCurrent = document.getElementById('work-current-result');

            buttonCurrent.addEventListener('click', function() {
              var pi = 0;
              var n = 1;
              for (i = 0; i <= 1000000000; i++) {
                pi = pi + (4/n) - (4 / (n + 2));
                n = n + 4;
              }

              resultCurrent.innerHTML = pi;
            });
          </script>

          <div class="floater floater-right ">
            <button id="work-worker">Worker Thread</button> 
            <code id="work-worker-result">...</code>
          </div>

          <script>
            var buttonWorker = document.getElementById('work-worker');
            var resultWorker = document.getElementById('work-worker-result');

            try {
              var worker = new Worker('task.js');

              worker.onmessage = function(e) {
                resultWorker.innerHTML = e.data;
                console.log(e);
              };

              buttonWorker.addEventListener('click', function() {
                worker.postMessage({iterations: 1000000000});
              });
            } catch(e) {
              console.error(e);
              resultWorker.innerHTML = e.name;
            }

          </script>

          <h3>Web Workers</h3>
          <ul>
            <li>IE10, Firefox 3.5, Chrome 4, Safari 4, Opera 10.6</li>
            <li>Message Passing via JSON structures</li>
            <li>No deadlocks or race conditions, working with “copies”</li>
          </ul>

          <pre>
            <code class="javascript">
              // main.js
              var worker = new Worker('task.js');
              worker.postMessage({iterations: 5000000000});
              worker.onmessage = function(e) { console.log(e.data); };

              // task.js
              onmessage = function(e) {
                var pi = 0, n = 1;
                for (i = 0; i &lt;= e.data.iterations; i++) {
                  pi = pi + (4/n) - (4 / (n + 2)); n += 4;
                }
                postMessage(pi);
              };
            </code>
          </pre>
        </section>

        <section>
          <h3>Conclusion</h3>
          <ul>
            <li>The Single-Threaded JavaScript Event Loop is...
              <ul>
              <li>Great for I/O bound applications (most web apps)</li>
              <li>Horrible for CPU bound applications (do it in C)</li>
              <li>“Fakes” the feeling of a Multi-Threaded process</li>
              </ul>
            </li>
          </ul>
        </section>
      </div>
    </div>

    <script src="./reveal.js-3.2.0/lib/js/head.min.js"></script>
    <script src="./reveal.js-3.2.0/js/reveal.js"></script>

    <script>
      Reveal.initialize({
        center: true,
        history: true,
        transition: 'convex',
        dependencies: [
          {
            src: './reveal.js-3.2.0/plugin/highlight/highlight.js',
            async: true,
            callback: function() {
              hljs.initHighlightingOnLoad();
            }
          }
        ]
      });
    </script>
  </body>
</html>
